<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: #202020;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100dvh;
        }

        #game-board {
            --grid-size: 2;
            --cell-size: calc(80vmin / var(--grid-size));
            --cell-gap: calc(10vmin / var(--grid-size));
            position: relative;
            display: grid;
            grid-template-columns: repeat(var(--grid-size), var(--cell-size));
            grid-template-rows: repeat(var(--grid-size), var(--cell-size));
            gap: var(--cell-gap);
            padding: var(--cell-gap);
            border-radius: 1vmin;
            background-color: #404040;
        }

        .cell {
            background-color: #202020;
            border-radius: 1vmin;
            animation: 100ms;
        }

        .tile {
            --x: 0;
            --y: 0;
            --bg-color: #ffffff;
            position: absolute;
            top: calc(var(--y) * (var(--cell-size) + var(--cell-gap)) + var(--cell-gap));
            left: calc(var(--x) * (var(--cell-size) + var(--cell-gap)) + var(--cell-gap));
            display: flex;
            justify-content: center;
            align-items: center;
            height: var(--cell-size);
            width: var(--cell-size);
            border-radius: 1vmin;
            font-family: 'Arial', 'Roboto';
            font-weight: 700;
            font-size: calc(0.35 * var(--cell-size));
            background-color: var(--bg-color);
            color: #202020;
            transition: 100ms;
            animation: show 100ms;
        }

        @keyframes show {
            0% {
                opacity: 0.5;
                transform: scale(0);
            }
        }
    </style>
</head>

<body>
    <div id="game-board"></div>

    <script>
        class Tile {
            tile
            x
            y
            value

            constructor(gridElement, limit) {
                this.tile = document.createElement("div")
                this.tile.classList.add("tile")
                this.setValue(Math.pow(2, Math.ceil(Math.random() * Math.log2(limit))))
                gridElement.append(this.tile)
            }

            setXY(x, y) {
                this.x = x
                this.y = y
                this.tile.style.setProperty("--x", x)
                this.tile.style.setProperty("--y", y)
            }

            setValue(value) {
                this.value = value
                this.tile.textContent = value
                const color = Math.log2(value) * 35
                this.tile.style.setProperty("--bg-color", `hsl(${color}, 40%, 60%)`)
            }
        }



        class Cell {
            cell
            x
            y
            linkedTile

            constructor(gridElement, x, y) {
                this.cell = document.createElement("div")
                this.cell.classList.add("cell")
                this.x = x
                this.y = y
                gridElement.append(this.cell)
            }

            linkTile(tile) {
                tile.setXY(this.x, this.y)
                this.linkedTile = tile
            }

            isEmpty() {
                return !this.linkedTile
            }

            canAccept(newTile) {
                return (this.isEmpty() || this.linkedTile.value === newTile.value)
            }

            async mergeTiles(tile) {
                tile.setXY(this.x, this.y)
                await new Promise(resolve => setTimeout(resolve, 100))
                this.linkedTile.setValue(this.linkedTile.value + tile.value)
                tile.tile.remove()
            }
        }



        class Grid {
            gridSize
            cells = []
            cellsGroupedByColumn = []
            cellsGroupedByLine = []
            cellsGroupedByReversedColumn = []
            cellsGroupedByReversedLine = []

            constructor(gridElement, gridSize) {
                this.gridSize = gridSize
                gridElement.style.setProperty("--grid-size", gridSize)

                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        this.cells.push(new Cell(gridElement, j, i))
                    }
                }

                this.groupCellByColumn()
                this.groupCellByLine()
                this.groupCellByReversedColumn()
                this.groupCellByReversedLine()
            }

            getRandomEmptyCell() {
                const emptyCells = this.cells.filter(cell => cell.isEmpty())
                const randomIndex = Math.floor(Math.random() * emptyCells.length)
                return emptyCells[randomIndex]
            }

            groupCellByColumn() {
                for (let i = 0; i < this.gridSize; i++) {
                    const column = []
                    for (let j = 0; j < this.gridSize; j++) {
                        column.push(this.cells[this.gridSize * j + i])
                    }
                    this.cellsGroupedByColumn.push(column)
                }
            }
            groupCellByLine() {
                for (let i = 0; i < this.gridSize; i++) {
                    const line = []
                    for (let j = 0; j < this.gridSize; j++) {
                        line.push(this.cells[this.gridSize * i + j])
                    }
                    this.cellsGroupedByLine.push(line)
                }
            }
            groupCellByReversedColumn() {
                for (let i = 0; i < this.gridSize; i++) {
                    const reversedColumn = []
                    for (let j = this.gridSize - 1; j >= 0; j--) {
                        reversedColumn.push(this.cells[this.gridSize * j + i])
                    }
                    this.cellsGroupedByReversedColumn.push(reversedColumn)
                }
            }
            groupCellByReversedLine() {
                for (let i = 0; i < this.gridSize; i++) {
                    const reversedLine = []
                    for (let j = this.gridSize - 1; j >= 0; j--) {
                        reversedLine.push(this.cells[this.gridSize * i + j])
                    }
                    this.cellsGroupedByReversedLine.push(reversedLine)
                }
            }

            findMaxValueOfTile() {
                let maxValue = 0
                this.cells.forEach(cell => {
                    if (cell.linkedTile) {
                        maxValue = maxValue < cell.linkedTile.value ? cell.linkedTile.value : maxValue
                    }
                })
                return maxValue
            }

            moveUpTiles(oldGrid) {
                for (let i = 0; i < oldGrid.gridSize; i++) {
                    for (let j = 0; j < oldGrid.gridSize; j++) {
                        if (oldGrid.cells[i * oldGrid.gridSize + j].linkedTile) {
                            this.cells[i * this.gridSize + (j + 1)].linkTile(oldGrid.cells[i * oldGrid.gridSize + j].linkedTile)
                        }
                    }
                }
            }

            moveDownTiles(oldGrid) {
                for (let i = 0; i < oldGrid.gridSize; i++) {
                    for (let j = 0; j < oldGrid.gridSize; j++) {
                        if (oldGrid.cells[i * oldGrid.gridSize + j].linkedTile) {
                            this.cells[(i + 1) * this.gridSize + j].linkTile(oldGrid.cells[i * oldGrid.gridSize + j].linkedTile)
                        }
                    }
                }
            }

            moveLeftTiles(oldGrid) {
                for (let i = 0; i < oldGrid.gridSize; i++) {
                    for (let j = 0; j < oldGrid.gridSize; j++) {
                        if (oldGrid.cells[i * oldGrid.gridSize + j].linkedTile) {
                            this.cells[i * this.gridSize + j].linkTile(oldGrid.cells[i * oldGrid.gridSize + j].linkedTile)
                        }
                    }
                }
            }

            moveRightTiles(oldGrid) {
                for (let i = 0; i < oldGrid.gridSize; i++) {
                    for (let j = 0; j < oldGrid.gridSize; j++) {
                        if (oldGrid.cells[i * oldGrid.gridSize + j].linkedTile) {
                            this.cells[(i + 1) * this.gridSize + (j + 1)].linkTile(oldGrid.cells[i * oldGrid.gridSize + j].linkedTile)
                        }
                    }
                }
            }

            removeFromDOM() {
                this.cells.forEach(cell => {
                    cell.cell.remove()
                })
            }
        }



        const gameBoard = document.getElementById("game-board")

        let gridSize = 2
        let valueForExtension = 16
        let grid = new Grid(gameBoard, gridSize)

        grid.getRandomEmptyCell().linkTile(new Tile(gameBoard, 4))
        if (isMobileDevice()) {
            document.addEventListener('touchmove', function (e) {
                if (window.scrollY === 0) {
                    e.preventDefault();
                }
            }, { passive: false });
            setupInputByTouchscreen()
        } else {
            setupInputByKeyboard()
        }

        function setupInputByKeyboard() {
            window.addEventListener("keydown", (event) => {
                handleInput(event.key.slice(5))
                setupInputByKeyboard()
            }, { once: true })
        }

        function setupInputByTouchscreen() {
            let startX
            let startY
            window.addEventListener("touchstart", (event) => {
                startX = event.touches[0].clientX;
                startY = event.touches[0].clientY;
            }, { once: true })
            let diffX
            let diffY
            window.addEventListener("touchend", (event) => {
                diffX = event.changedTouches[0].clientX - startX;
                diffY = event.changedTouches[0].clientY - startY;
                if (Math.abs(diffY) > Math.abs(diffX)) {
                    if (diffY < 0) {
                        handleInput("Up")
                        setupInputByTouchscreen()
                    }
                    else {
                        handleInput("Down")
                        setupInputByTouchscreen()
                    }
                } else {
                    if (diffX < 0) {
                        handleInput("Left")
                        setupInputByTouchscreen()
                    }
                    else {
                        handleInput("Right")
                        setupInputByTouchscreen()
                    }
                }
            }, { once: true })
        }

        async function handleInput(direction) {
            switch (direction) {
                case "Up":
                    if (!canMoveUp()) {
                        return
                    }
                    moveUp();
                    break
                case "Down":
                    if (!canMoveDown()) {
                        return
                    }
                    moveDown();
                    break
                case "Left":
                    if (!canMoveLeft()) {
                        return
                    }
                    moveLeft()
                    break
                case "Right":
                    if (!canMoveRight()) {
                        return
                    }
                    moveRight()
                    break
            }

            await new Promise(resolve => setTimeout(resolve, 100))

            const maxValue = grid.findMaxValueOfTile()
            if (maxValue === 2048) {
                await new Promise(resolve => setTimeout(resolve, 100))
                alert("YOU WON!")
                window.location.reload(true)
                return
            }
            if (maxValue === valueForExtension) {
                gridSize++
                valueForExtension = maxValue * 4

                const oldGrid = grid

                grid = new Grid(gameBoard, gridSize)
                switch (direction) {
                    case "Up":
                        grid.moveUpTiles(oldGrid)
                        break
                    case "Down":
                        grid.moveDownTiles(oldGrid)
                        break
                    case "Left":
                        grid.moveLeftTiles(oldGrid)
                        break
                    case "Right":
                        grid.moveRightTiles(oldGrid)
                        break
                }

                oldGrid.removeFromDOM()
            }

            grid.getRandomEmptyCell().linkTile(new Tile(gameBoard, maxValue))

            if (!canMoveUp() && !canMoveDown() && !canMoveLeft() && !canMoveRight()) {
                await new Promise(resolve => setTimeout(resolve, 100))
                alert("Try again!")
                window.location.reload(true)
                return
            }
        }

        function moveUp() {
            slideTiles(grid.cellsGroupedByColumn)
        }

        function moveDown() {
            slideTiles(grid.cellsGroupedByReversedColumn)
        }

        function moveLeft() {
            slideTiles(grid.cellsGroupedByLine)
        }

        function moveRight() {
            slideTiles(grid.cellsGroupedByReversedLine)
        }

        function slideTiles(groupedCells) {
            const promises = []

            for (let i = 0; i < groupedCells.length; i++) {
                const group = groupedCells[i]

                let usedCells = []

                for (let j = 1; j < group.length; j++) {
                    if (group[j].isEmpty()) {
                        continue
                    }
                    const cellWithTile = group[j]

                    let targetCell
                    for (let k = j - 1; k >= 0 && group[k].canAccept(cellWithTile.linkedTile); k--) {
                        targetCell = group[k]
                    }

                    if (!targetCell) {
                        continue
                    } else if (targetCell.isEmpty()) {
                        targetCell.linkTile(cellWithTile.linkedTile)
                    } else if (usedCells.includes(targetCell)) {
                        continue
                    } else {
                        targetCell.mergeTiles(cellWithTile.linkedTile)
                        usedCells.push(targetCell)
                    }
                    cellWithTile.linkedTile = null
                }
            }
        }

        function canMoveUp() {
            return canMove(grid.cellsGroupedByColumn)
        }

        function canMoveDown() {
            return canMove(grid.cellsGroupedByReversedColumn)
        }

        function canMoveLeft() {
            return canMove(grid.cellsGroupedByLine)
        }

        function canMoveRight() {
            return canMove(grid.cellsGroupedByReversedLine)
        }

        function canMove(groupedCells) {
            for (let i = 0; i < groupedCells.length; i++) {
                const group = groupedCells[i]

                for (let j = 1; j < group.length; j++) {
                    if (group[j].isEmpty()) {
                        continue
                    }
                    const cellWithTile = group[j]
                    if (cellWithTile.isEmpty()) {
                        return true
                    }

                    const targetCell = group[j - 1]
                    if (targetCell.canAccept(cellWithTile.linkedTile)) {
                        return true
                    }
                }
            }
            return false
        }

        function isMobileDevice() {
            const userAgent = navigator.userAgent.toLowerCase();

            const mobileKeywords = [
                'android', 'iphone', 'ipod', 'blackberry',
                'windows phone', 'webos', 'opera mini',
                'mobile', 'tablet', 'ipad'
            ];

            return mobileKeywords.some(keyword => userAgent.includes(keyword));
        }
    </script>
</body>

</html>